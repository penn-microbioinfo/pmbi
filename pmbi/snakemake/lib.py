from snakemake.shell import shell
from snakemake.io import InputFiles, OutputFiles
import itertools
import shutil
import pathlib
import os

def path_difference(p1, p2):
    p1 = pathlib.Path(p1)
    p2 = pathlib.Path(p2)
    diff = []
    for pair in itertools.zip_longest(p1.parts, p2.parts):
        if pair[0] == pair[1]:
            continue
        else:
            diff.append(pair)
    return list(zip(*diff))

class PushPullFiles:

    """
    This decorator class copies snakemake rule input files over to SINK, does func, and then copies the output back to SOURCE
    It chanegs the values for input and output files in the snakemake rules below such that the ones that actually get passed to the commands are at SINK instead of SOURCE (might look confusing)
    """

    def __init__(self, src: str, sink: str, input: InputFiles, output: InputFiles):
        if len(input.keys()) == 0  or len(output.keys()) == 0:
            raise NotImplementedError("PushPullFiles does not yet support InputFiles or OutputFiles without names.")

        self.src = src
        self.sink = sink
        self.input_at_source = input
        self.output_at_source = output
        self.input_at_sink = None
        self.output_at_sink = None
        self.tmp = os.path.join(self.sink, "tmp")


    def __call__(self, func):
        def wrapper(input, output, wildcards, *args, **kwargs):
            self._chdir_sink()
            self._update_paths() 
            self._mkdir_at_sink()
            self._copy_files(self.input_at_source, self.input_at_sink)
            func(self.input_at_sink, self.output_at_sink, wildcards, *args, **kwargs)
            self._mkdir_at_source()
            self._copy_files(self.output_at_sink, self.output_at_source)
            #self._clean_sink()
        return wrapper
            
    # Change dir to sink to avoid the bulid up of temp files
    def _chdir_sink(self):
        shell(f"cd {self.sink}")
        shell(f"if [ ! -d {self.tmp} ]; then mkdir {self.tmp}; fi")

    # Generate future paths to files at the sink, which will be valid after _copy_files()
    def _update_paths(self):
        self.input_at_sink = InputFiles(fromdict={k: os.path.join(self.sink, *path_difference(self.src,v)[1]) for k,v in self.input_at_source.items()})
        self.output_at_sink = OutputFiles(fromdict={k: os.path.join(self.sink, *path_difference(self.src,v)[1]) for k,v in self.output_at_source.items()})
    
    # Make any needed directories at the sink based on future paths generated by _update_paths()  
    def _mkdir_at_sink(self):
        for dn in [os.path.dirname(p) for p in itertools.chain(self.input_at_sink, self.output_at_sink)]:
            if not os.path.isdir(dn):
                shell("mkdir -p {dn}")

    # Make any needed directories at the sourced based on the final paths of output files
    def _mkdir_at_source(self):
        for dn in [os.path.dirname(p) for p in self.output_at_source]:
            if not os.path.isdir(dn):
                shell("mkdir -p {dn}")

    # Copy the files from source to sink
    def _copy_files(self, start, end):
        for s,e in zip([v for _k,v in start.items()], [v for _k,v in end.items()]):
            shell(f"cp {s} {e}")

    def _clean_sink(self):
        if os.path.isdir(self.tmp):
            shutil.rmtree(self.tmp)
        for dn in [os.path.join(self.sink, path_difference(self.sink,f)[1][0]) for f in itertools.chain(self.input_at_sink, self.output_at_sink)]:
            if os.path.isdir(dn):
                shutil.rmtree(dn)
