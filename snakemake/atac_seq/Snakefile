import os
import shutil
import functools
import itertools
import pathlib
from snakemake.io import InputFiles, OutputFiles

SOURCE="/atac_data/pipeline/"
SINK="/local-ebs"

### SOURCE="/atac_data/pipeline/test/source"
### SINK="/atac_data/pipeline/test/sink"

### REFERENCE="GCA_000001635.9_GRCm39_genomic.fna"
REFERENCE="GRCm38.primary_assembly.genome.fa"

BLACKLISTS=[
    "/atac_data/pipeline/ref/mm10-blacklist.v2.bed" \
    #,"/atac_data/ATAC-seq-fromNovo/ref/mm10_peaks.narrowPeak"
]

THREADS=16
MEM=30000 #Mb
DISKSPACE=500000 #Mb
MTCHROM="chrM"

SAMPLES = [x.split("-")[0] for x in os.listdir(os.path.join(SOURCE, "fastq", "raw")) if x.endswith("1.fq.gz")]

def path_difference(p1, p2):
    p1 = pathlib.Path(p1)
    p2 = pathlib.Path(p2)
    diff = []
    for pair in itertools.zip_longest(p1.parts, p2.parts):
        if pair[0] == pair[1]:
            continue
        else:
            diff.append(pair)
    return list(zip(*diff))

class PushPullFiles:

    """
    This decorator class copies snakemake rule input files over to SINK, does func, and then copies the output back to SOURCE
    It chanegs the values for input and output files in the snakemake rules below such that the ones that actually get passed to the commands are at SINK instead of SOURCE (might look confusing)
    """

    def __init__(self, src: str, sink: str, input: InputFiles, output: InputFiles):
        if len(input.keys()) == 0  or len(output.keys()) == 0:
            raise NotImplementedError("PushPullFiles does not yet support InputFiles or OutputFiles without names.")

        self.src = src
        self.sink = sink
        self.input_at_source = input
        self.output_at_source = output
        self.input_at_sink = None
        self.output_at_sink = None
        self.tmp = os.path.join(self.sink, "tmp")


    def __call__(self, func):
        def wrapper(input, output, wildcards, *args, **kwargs):
            self._chdir_sink()
            self._update_paths() 
            self._mkdir_at_sink()
            self._copy_files(self.input_at_source, self.input_at_sink)
            func(self.input_at_sink, self.output_at_sink, wildcards, *args, **kwargs)
            self._mkdir_at_source()
            self._copy_files(self.output_at_sink, self.output_at_source)
            #self._clean_sink()
        return wrapper
            
    # Change dir to sink to avoid the bulid up of temp files
    def _chdir_sink(self):
        shell(f"cd {self.sink}")
	shell(f"if [ ! -d {self.tmp} ]; then mkdir {self.tmp}; fi")

    # Generate future paths to files at the sink, which will be valid after _copy_files()
    def _update_paths(self):
        self.input_at_sink = InputFiles(fromdict={k: os.path.join(self.sink, *path_difference(self.src,v)[1]) for k,v in self.input_at_source.items()})
        self.output_at_sink = OutputFiles(fromdict={k: os.path.join(self.sink, *path_difference(self.src,v)[1]) for k,v in self.output_at_source.items()})
    
    # Make any needed directories at the sink based on future paths generated by _update_paths()  
    def _mkdir_at_sink(self):
        for dn in [os.path.dirname(p) for p in itertools.chain(self.input_at_sink, self.output_at_sink)]:
            if not os.path.isdir(dn):
                shell("mkdir -p {dn}")

    # Make any needed directories at the sourced based on the final paths of output files
    def _mkdir_at_source(self):
        for dn in [os.path.dirname(p) for p in self.output_at_source]:
            if not os.path.isdir(dn):
                shell("mkdir -p {dn}")

    # Copy the files from source to sink
    def _copy_files(self, start, end):
        for s,e in zip([v for _k,v in start.items()], [v for _k,v in end.items()]):
            shell(f"cp {s} {e}")

    def _clean_sink(self):
        if os.path.isdir(self.tmp):
            shutil.rmtree(self.tmp)
        for dn in [os.path.join(self.sink, path_difference(self.sink,f)[1][0]) for f in itertools.chain(self.input_at_sink, self.output_at_sink)]:
            if os.path.isdir(dn):
                shutil.rmtree(dn)

rule all:
    input:
            expand("{src}/bam/{sample}.mm11.sorted.filtered.bam", src=SOURCE, sample=SAMPLES)

rule trimgalore:
    input:
            r1raw="{SOURCE}/fastq/raw/{sample}-1A_22FKY5LT3_L2_1.fq.gz",
            r2raw="{SOURCE}/fastq/raw/{sample}-1A_22FKY5LT3_L2_2.fq.gz"
    output:
            r1trim="{SOURCE}/fastq/trim/{sample}_val_1.fq.gz",
            r2trim="{SOURCE}/fastq/trim/{sample}_val_2.fq.gz"
    resources:
            slurm_partition="c6id",
            tasks=1,
            cpus_per_task=THREADS,
            mem_mb=MEM,
            disk_mb=DISKSPACE,
            runtime=6000
    run:
            @PushPullFiles(SOURCE, SINK, input, output)
            def trimgalore(input, output, wildcards):
                shell(f"trim_galore --paired -j 8 --stringency 5 -o {os.path.dirname(output.r1trim)} --basename {wildcards.sample} {input.r1raw} {input.r2raw}")
            trimgalore(input, output, wildcards)

rule bowtie:
    input:
            btibase=f"{SOURCE}/ref/{REFERENCE}",
            r1="{SOURCE}/fastq/trim/{sample}_val_1.fq.gz",
            r2="{SOURCE}/fastq/trim/{sample}_val_2.fq.gz"
    output:
            bam="{SOURCE}/bam/{sample}.mm11.sorted.bam",
            bai="{SOURCE}/bam/{sample}.mm11.sorted.bam.bai"
    resources:
            slurm_partition="c6id",
            tasks=1,
            cpus_per_task=THREADS,
            mem_mb=MEM,
            disk_mb=DISKSPACE,
            runtime=6000
    run:
            @PushPullFiles(SOURCE, SINK, input, output)
            def bowtie(input, output, wildcards):

                # this one is a special case right now that I need to fix
                shell(f"cp {os.path.join(SOURCE, 'ref', os.path.basename(input.btibase))}.*.bt2 {SINK}/ref/.")

                shell(f"bowtie2 --very-sensitive-local --dovetail --no-discordant --no-mixed -p {THREADS} -x {input.btibase} -1 {input.r1} -2 {input.r2} | samtools view -b | samtools sort -T {SINK}/tmp/samtoolstmp > {output.bam}")
                shell(f"samtools index {output.bam}")
            bowtie(input, output, wildcards)

rule filter_bam:
    input:
        bam="{SOURCE}/bam/{sample}.mm11.sorted.bam",
        bai="{SOURCE}/bam/{sample}.mm11.sorted.bam.bai",
    output:
        filtbam="{SOURCE}/bam/{sample}.mm11.sorted.filtered.bam"
    resources:
        slurm_partition="c6id",
        tasks=1,
        cpus_per_task=1,
        mem_mb=4000,
        disk_mb=DISKSPACE,
        runtime=6000
    run:
        @PushPullFiles(SOURCE, SINK, input, output)
        def filter_out_mt(input, output, wildcards):
            shell(f"samtools idxstats {input.bam} | cut -f1 | grep -v {MTCHROM} | xargs samtools view -b {input.bam} > {output.filtbam}.rmMt")
            shell(f"samtools rmdup --output-fmt BAM {output.filtbam}.rmMt {output.filtbam}.rmdup")
            shell(f"samtools view -f 2 -q 20 -b {output.filtbam}.rmdup > {output.filtbam}.bltmp")
            for i,blf in enumerate(BLACKLISTS):
                shell(f"bedtools intersect -v -a {output.filtbam}.bltmp -b {blf} -wa > {output.filtbam}.bltmp.tmp")
		shell(f"mv {output.filtbam}.bltmp.tmp {output.filtbam}.bltmp")
            shell(f"mv {output.filtbam}.bltmp {output.filtbam}")
        filter_out_mt(input, output, wildcards)
